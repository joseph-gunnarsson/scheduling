// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: group.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUserToGroup = `-- name: AddUserToGroup :one
INSERT INTO user_groups (user_id, group_id)
VALUES ($1, $2)
RETURNING user_id, group_id, joined_at
`

type AddUserToGroupParams struct {
	UserID  int32 `json:"user_id"`
	GroupID int32 `json:"group_id"`
}

func (q *Queries) AddUserToGroup(ctx context.Context, arg AddUserToGroupParams) (UserGroup, error) {
	row := q.db.QueryRow(ctx, addUserToGroup, arg.UserID, arg.GroupID)
	var i UserGroup
	err := row.Scan(&i.UserID, &i.GroupID, &i.JoinedAt)
	return i, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO groups (name, description, owner_id, created_at, updated_at)
VALUES ($1, $2, $3, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, name, description, owner_id, created_at, updated_at
`

type CreateGroupParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	OwnerID     pgtype.Int4 `json:"owner_id"`
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRow(ctx, createGroup, arg.Name, arg.Description, arg.OwnerID)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE FROM groups
WHERE id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteGroup, id)
	return err
}

const deleteUserFromGroup = `-- name: DeleteUserFromGroup :exec
DELETE FROM user_groups
WHERE user_id = $1 AND group_id = $2
`

type DeleteUserFromGroupParams struct {
	UserID  int32 `json:"user_id"`
	GroupID int32 `json:"group_id"`
}

func (q *Queries) DeleteUserFromGroup(ctx context.Context, arg DeleteUserFromGroupParams) error {
	_, err := q.db.Exec(ctx, deleteUserFromGroup, arg.UserID, arg.GroupID)
	return err
}

const getGroupByID = `-- name: GetGroupByID :one
SELECT id, name, description, owner_id, created_at, updated_at
FROM groups
WHERE id = $1
`

func (q *Queries) GetGroupByID(ctx context.Context, id int32) (Group, error) {
	row := q.db.QueryRow(ctx, getGroupByID, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupMembers = `-- name: GetGroupMembers :many
SELECT 
    u.id AS user_id,
    u.username,
    u.email,
    u.first_name,
    u.last_name,
    u.created_at AS user_created_at,
    u.updated_at AS user_updated_at,
    ug.joined_at
FROM user_groups ug
JOIN users u ON ug.user_id = u.id
WHERE ug.group_id = $1
`

type GetGroupMembersRow struct {
	UserID        int32              `json:"user_id"`
	Username      string             `json:"username"`
	Email         string             `json:"email"`
	FirstName     pgtype.Text        `json:"first_name"`
	LastName      pgtype.Text        `json:"last_name"`
	UserCreatedAt pgtype.Timestamptz `json:"user_created_at"`
	UserUpdatedAt pgtype.Timestamptz `json:"user_updated_at"`
	JoinedAt      pgtype.Timestamptz `json:"joined_at"`
}

func (q *Queries) GetGroupMembers(ctx context.Context, groupID int32) ([]GetGroupMembersRow, error) {
	rows, err := q.db.Query(ctx, getGroupMembers, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupMembersRow
	for rows.Next() {
		var i GetGroupMembersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.UserCreatedAt,
			&i.UserUpdatedAt,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsByOwner = `-- name: GetGroupsByOwner :many
SELECT id, name, description, owner_id, created_at, updated_at FROM groups
WHERE owner_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetGroupsByOwner(ctx context.Context, ownerID pgtype.Int4) ([]Group, error) {
	rows, err := q.db.Query(ctx, getGroupsByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserGroups = `-- name: GetUserGroups :many
SELECT 
    g.id AS group_id,
    g.name AS group_name,
    g.description AS group_description,
    g.owner_id AS group_owner_id,
    g.created_at AS group_created_at,
    g.updated_at AS group_updated_at,
    ug.joined_at AS user_joined_at
FROM user_groups ug
JOIN groups g ON ug.group_id = g.id
WHERE ug.user_id = $1
`

type GetUserGroupsRow struct {
	GroupID          int32              `json:"group_id"`
	GroupName        string             `json:"group_name"`
	GroupDescription pgtype.Text        `json:"group_description"`
	GroupOwnerID     pgtype.Int4        `json:"group_owner_id"`
	GroupCreatedAt   pgtype.Timestamptz `json:"group_created_at"`
	GroupUpdatedAt   pgtype.Timestamptz `json:"group_updated_at"`
	UserJoinedAt     pgtype.Timestamptz `json:"user_joined_at"`
}

func (q *Queries) GetUserGroups(ctx context.Context, userID int32) ([]GetUserGroupsRow, error) {
	rows, err := q.db.Query(ctx, getUserGroups, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserGroupsRow
	for rows.Next() {
		var i GetUserGroupsRow
		if err := rows.Scan(
			&i.GroupID,
			&i.GroupName,
			&i.GroupDescription,
			&i.GroupOwnerID,
			&i.GroupCreatedAt,
			&i.GroupUpdatedAt,
			&i.UserJoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const patchGroup = `-- name: PatchGroup :one
UPDATE groups
SET 
    name = COALESCE($3, name),
    description = COALESCE($2, description),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, description, owner_id, created_at, updated_at
`

type PatchGroupParams struct {
	ID          int32       `json:"id"`
	Description pgtype.Text `json:"description"`
	Name        pgtype.Text `json:"name"`
}

func (q *Queries) PatchGroup(ctx context.Context, arg PatchGroupParams) (Group, error) {
	row := q.db.QueryRow(ctx, patchGroup, arg.ID, arg.Description, arg.Name)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGroup = `-- name: UpdateGroup :one
UPDATE groups
SET name = $2,
    description = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, description, owner_id, created_at, updated_at
`

type UpdateGroupParams struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateGroup(ctx context.Context, arg UpdateGroupParams) (Group, error) {
	row := q.db.QueryRow(ctx, updateGroup, arg.ID, arg.Name, arg.Description)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
