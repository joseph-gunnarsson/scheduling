// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: shift.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createShift = `-- name: CreateShift :one
INSERT INTO shifts (user_id, group_id, name, start_time, end_time, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, user_id, group_id, name, start_time, end_time, created_at, updated_at
`

type CreateShiftParams struct {
	UserID    pgtype.Int4        `json:"user_id"`
	GroupID   pgtype.Int4        `json:"group_id"`
	Name      string             `json:"name"`
	StartTime pgtype.Timestamptz `json:"start_time"`
	EndTime   pgtype.Timestamptz `json:"end_time"`
}

// Create a new shift
func (q *Queries) CreateShift(ctx context.Context, arg CreateShiftParams) (Shift, error) {
	row := q.db.QueryRow(ctx, createShift,
		arg.UserID,
		arg.GroupID,
		arg.Name,
		arg.StartTime,
		arg.EndTime,
	)
	var i Shift
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.Name,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteShift = `-- name: DeleteShift :exec
DELETE FROM shifts
WHERE id = $1 AND user_id = $2 AND group_id = $3
`

type DeleteShiftParams struct {
	ID      int32       `json:"id"`
	UserID  pgtype.Int4 `json:"user_id"`
	GroupID pgtype.Int4 `json:"group_id"`
}

// Delete a shift by ID
func (q *Queries) DeleteShift(ctx context.Context, arg DeleteShiftParams) error {
	_, err := q.db.Exec(ctx, deleteShift, arg.ID, arg.UserID, arg.GroupID)
	return err
}

const getShiftByID = `-- name: GetShiftByID :one
SELECT id, user_id, group_id, name, start_time, end_time, created_at, updated_at
FROM shifts
WHERE id = $1
`

// Get shift by ID
func (q *Queries) GetShiftByID(ctx context.Context, id int32) (Shift, error) {
	row := q.db.QueryRow(ctx, getShiftByID, id)
	var i Shift
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.Name,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllShifts = `-- name: ListAllShifts :many
SELECT id, user_id, group_id, name, start_time, end_time, created_at, updated_at
FROM shifts
ORDER BY start_time ASC
`

// List all shifts
func (q *Queries) ListAllShifts(ctx context.Context) ([]Shift, error) {
	rows, err := q.db.Query(ctx, listAllShifts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shift
	for rows.Next() {
		var i Shift
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.Name,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShiftsByGroup = `-- name: ListShiftsByGroup :many
SELECT id, user_id, group_id, name, start_time, end_time, created_at, updated_at
FROM shifts
WHERE group_id = $1
ORDER BY start_time ASC
`

// List all shifts in a specific group
func (q *Queries) ListShiftsByGroup(ctx context.Context, groupID pgtype.Int4) ([]Shift, error) {
	rows, err := q.db.Query(ctx, listShiftsByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shift
	for rows.Next() {
		var i Shift
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.Name,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShiftsByGroupWithNames = `-- name: ListShiftsByGroupWithNames :many
SELECT
    shifts.id AS shift_id,
    shifts.name AS shift_name,
    shifts.start_time,
    shifts.end_time,
    shifts.created_at AS shift_created_at,
    shifts.updated_at AS shift_updated_at,
    users.id AS user_id,
    users.first_name AS user_first_name,
    users.last_name AS user_last_name
FROM
    shifts
JOIN
    users ON shifts.user_id = users.id
WHERE
    shifts.group_id = $1
ORDER BY
    shifts.start_time ASC
`

type ListShiftsByGroupWithNamesRow struct {
	ShiftID        int32              `json:"shift_id"`
	ShiftName      string             `json:"shift_name"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
	EndTime        pgtype.Timestamptz `json:"end_time"`
	ShiftCreatedAt pgtype.Timestamptz `json:"shift_created_at"`
	ShiftUpdatedAt pgtype.Timestamptz `json:"shift_updated_at"`
	UserID         int32              `json:"user_id"`
	UserFirstName  pgtype.Text        `json:"user_first_name"`
	UserLastName   pgtype.Text        `json:"user_last_name"`
}

// Get all shifts by group ID including user names
func (q *Queries) ListShiftsByGroupWithNames(ctx context.Context, groupID pgtype.Int4) ([]ListShiftsByGroupWithNamesRow, error) {
	rows, err := q.db.Query(ctx, listShiftsByGroupWithNames, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListShiftsByGroupWithNamesRow
	for rows.Next() {
		var i ListShiftsByGroupWithNamesRow
		if err := rows.Scan(
			&i.ShiftID,
			&i.ShiftName,
			&i.StartTime,
			&i.EndTime,
			&i.ShiftCreatedAt,
			&i.ShiftUpdatedAt,
			&i.UserID,
			&i.UserFirstName,
			&i.UserLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShiftsByUser = `-- name: ListShiftsByUser :many
SELECT id, user_id, group_id, name, start_time, end_time, created_at, updated_at
FROM shifts
WHERE user_id = $1
ORDER BY start_time ASC
`

// List all shifts for a specific user across all groups
func (q *Queries) ListShiftsByUser(ctx context.Context, userID pgtype.Int4) ([]Shift, error) {
	rows, err := q.db.Query(ctx, listShiftsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shift
	for rows.Next() {
		var i Shift
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.Name,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShiftsByUserAndGroup = `-- name: ListShiftsByUserAndGroup :many
SELECT id, user_id, group_id, name, start_time, end_time, created_at, updated_at
FROM shifts
WHERE user_id = $1 AND group_id = $2
ORDER BY start_time ASC
`

type ListShiftsByUserAndGroupParams struct {
	UserID  pgtype.Int4 `json:"user_id"`
	GroupID pgtype.Int4 `json:"group_id"`
}

// List all shifts for a specific user in a group
func (q *Queries) ListShiftsByUserAndGroup(ctx context.Context, arg ListShiftsByUserAndGroupParams) ([]Shift, error) {
	rows, err := q.db.Query(ctx, listShiftsByUserAndGroup, arg.UserID, arg.GroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shift
	for rows.Next() {
		var i Shift
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.Name,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateShift = `-- name: UpdateShift :exec
UPDATE shifts
SET name = $1,
    start_time = $2,
    end_time = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $4 AND user_id = $5 AND group_id = $6
`

type UpdateShiftParams struct {
	Name      string             `json:"name"`
	StartTime pgtype.Timestamptz `json:"start_time"`
	EndTime   pgtype.Timestamptz `json:"end_time"`
	ID        int32              `json:"id"`
	UserID    pgtype.Int4        `json:"user_id"`
	GroupID   pgtype.Int4        `json:"group_id"`
}

// Update a shift
func (q *Queries) UpdateShift(ctx context.Context, arg UpdateShiftParams) error {
	_, err := q.db.Exec(ctx, updateShift,
		arg.Name,
		arg.StartTime,
		arg.EndTime,
		arg.ID,
		arg.UserID,
		arg.GroupID,
	)
	return err
}
